# آزمایش دوم

## مرحله دوم

| ردیف | محل اعمال تغییرات      | عنوان تغییر                                      | شرحی کوتاه از تغییر                                                                                                           |
|------|------------------------|--------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
| ۱    | MessageService         | افزودن تابع ارسال پیام تلگرامی                   | افزودن یک تابع void با عنوان sendTelegramMessage                                                                              |
| ۲    | TelegramMessage        | افزودن متغییر آیدی مبدا                          | افزودن متغییر String به نام sourceUsername                                                                                    |
| ۳    | TelegramMessage        | افزودن متغییر آیدی مقصد                          | افزودن متغییر String به نام targetUsername                                                                                    |
| ۴    | TelegramMessage        | افزودن تابع دریافت آیدی مبدا                     | افزودن تابع String با عنوان getSourceUsername                                                                                 |
| ۵    | TelegramMessage        | افزودن تابع تنظیم آیدی مبدا                      | افزودن تابع void با عنوان setSourceUsername                                                                                   |
| ۶    | TelegramMessage        | افزودن تابع دریافت آیدی مقصد                     | افزودن تابع String با عنوان geُtTargetUsername                                                                                |
| ۷    | TelegramMessage        | افزودن تابع تنظیم آیدی مبدا                      | افزودن تابع void با عنوان setTargetUsername                                                                                   |
| ۸    | TelegramMessageService | افزودن توابع ارسال پیام‌های ایمیل، SMS و تلگرامی | افزودن توابع void sendSmsMessage و void sendEmailMessage با بنده خالی و تابع void sendTelegramMessage برای ارسال پیام تلگرامی |
| ۹    | TelegramMessageService | افزودن تابع اعتبارسنجی آیدی تلگرام               | افزودن تابع boolean validateUsername                                                                                          |
| ۱۰   | EmailMessageService    | پیاده‌سازی تابع ارسال پیام تلگرامی               | پیاده‌سازی یک تابع با بدنه خالی که از پدر به ارث رسیده است                                                                    |
| ۱۱   | SmsMessageService      | پیاده‌سازی تابع ارسال پیام تلگرامی               | پیاده‌سازی یک تابع با بدنه خالی که از پدر به ارث رسیده است                                                                    |
| ۱۲   | Main                   | افزودن متن برای حالت ارسال پیام تلگرامی          | افزودن خط System.out.println("In order to send Telegram message enter 3")                                                     |
| ۱۳   | Main                   | هندل کردن ورودی ارسال پیام تلگرامی               | اضافه کردن یک switch case برای حالت تلگرامی و ساخت TelegramMessage                                                            |
| ۱۴   | Main                   | ارسال پیام تلگرامی                               | اضافه کردن else if و ساخت سرویس مناسب برای حالت ارسال پیام تلگرامی                                                            |

## مرحله سوم 
| اصل                             | موضوع      | موارد                                                                                                                                       |
|---------------------------------|------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| اصل ۱                           | موارد تحقق | برای هر حالت از ارسال پیام، کلاس‌های جدا وجود دارد و مسئولیت هر کدام جداست. برای اعتبارسنجی و ارسال در هر سرویس متد جدا وجود دارد           |
| Single Responsibility           | موارد نقض  | واسط MessageService چندین کار مختلف را انجام می‌دهد. همچنین کلاس Main نقش‌های مختلف مثل ورودی گرفتن، ساخت پیام و ارسال پیام را ایفا می‌کند. |
| اصل ۲                           | موارد تحقق | می‌توان انواع مختلف کلاس‌های Message را به پروژه اضافه کرد                                                                                  |
| Open-Close Principle            | موارد نقض  | افزودن یک سرویس ارسال پیام جدید، باعث ویرایش در واسط MessageService و تمام پیاده‌سازی‌های دیگر آن شد                                        |
| اصل ۳                           | موارد تحقق | رابطه بین کلاس Message و فرزندان یک رابطه is-a است                                                                                          |
| Liskov Substitution Principle   | موارد نقض  | رابطه بین واسط MessageService و فرزندانش یک رابطه درست نیست و رفتارهای اضافی را به فرزندان تحمیل کرده است                                   |
| اصل ۴                           | موارد تحقق | واسط MessageService از توابع مجزا برای هر یک از سرویس‌ها استفاده کرده است                                                                   |
| Interface Segregation Principle | موارد نقض  | واسط MessageService شامل توابعی است که همه سرویس‌ها به آن نیاز ندارند و در آن‌ها بدنه تابع خالی است                                         |
| اصل ۵                           | موارد تحقق | در کلاس Main تاحدی وابستگی‌ها به واسط MessageService است بجای کلاس‌های خاص                                                                  |
| Dependency Inversion Principle  | موارد نقض  | البته همچنان در Main به صورت مستقیم از کلاس‌های خاص سرویس استفاده شده است                                                                   |

## مرحله چهارم
| اصل مربوطه                      | علت نقض                                                                                                                | راه‌حل پیشنهادی                                                                                                                                                                                                                                                                                                                                       |
|---------------------------------|------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Open-Close Principle            | برای اضافه کردن یک نوع جدید از پیام لازم است MessageService و کلاس Main تغییر کنند                                     | کافی است پیام‌ها از یک واسط مشترک استفاده کنند. در این حالت MessageService تنها شامل یک متد sendMessage است و هر سرویس این متد را پیاده‌سازی می‌کند. در این حالت برای اضافه کردن یک نوع پیام نیازی به تغییر MessageService نیست. برای تغییرات در Main هم می‌توان از یک Factory استفاده کرد تا برای اضافه کردن یک نوع پیام جدید نیاز به تغییر آن نباشد |
| Liskov Substitution Principle   | رفتارهای تعریف شده در MessageService لزوما در تمام فرزندان تعریف نشده است                                              | واسط MessageService نیازی نیست برای هر نوع پیام یک تابع داشته باشد و کافی است که تابع کلی برای ارسال پیام داشته باشد.                                                                                                                                                                                                                                 |
| Interface Segregation Principle | سرویس‌های نیازمند پیاده‌سازی توابعی از واسط MessageService هستند که در واقع به آن‌ها نیازی نیست و بدنه خالی دارند      | مانند قسمت بالا اگر MessageService تنها یک تابع کلی داشته باشد مشکل برطرف خواهد شد                                                                                                                                                                                                                                                                    |
| Dependency Inversion Principle  | در تابع Main در خیلی از موارد بجای اینکه از کلاس abstract استفاده شود، به صورت مستقیم از کلاس concrete استفاده شده است | راه‌حل‌های بالا تا حدی مسئله را حل می‌کنند. همچنین اضافه کردن یک factory می‌تواند باعث شود که در کلاس Main فقط از کلاس‌های abstract استفاده کرد و به کلاس concrete وابسته نبود                                                                                                                                                                        |

## سوالات پایانی

1. اگر اصول شی‌گرایی از ابتدا برقرار بود و شما سرویس جدید را به پروژه اضافه می‌کردید، چند مورد از تغییرات ثبت شده در جدول مرحله دوم حذف می‌شد؟ و در نهایت با چند تغییر در سطح کد، این سرویس اضافه می‌شد؟ (عدد آن را حتماً اعلام کنید.)

دیگر نیازی به اعمال تغییر در فایل هایی به جز همان فایل های مربوط به TelegramMessage نبود و همچنین در خود سرویس جدید هم نیاز به داشتن بدنه دیگر سرویس ها نبود لذا در مجموع 7 مورد از تغییرات موجود حذف میشدند و از طرفی MessageFactory هم باید تغییر میکرد پس در مجموع 14 تغییر به 8 تغییر کاهش می یافت.


2. با توجه به آنچه که انجام دادید، در دو خط توضیح دهید که رعایت اصول شی‌گرایی، چه مزایایی را برای پروژه شما فراهم می‌کند؟

از سوال قبل مشخص است که اولاً تعداد تغییرات لازم برای توسعه پروژه را کمتر میکند که نتیجۀ مستقیمش افزایش سرعت توسعه در دراز مدت خواهد بود و همچنین ساختار منظم تر پروژه پیدا کردن مواردی که به آن ها احتیاج داریم را برای توسعه دهنده بسیار ساده تر میکند.
